// SPDX-FileCopyrightText: Nextcloud GmbH
// SPDX-FileCopyrightText: 2026 Marino Faggiana
// SPDX-License-Identifier: GPL-3.0-or-later

import UIKit

/// Entry point of the application.
///
/// This call bootstraps the UIKit application using a custom `UIApplication`
/// subclass (`NCApplication`) in order to intercept and observe low-level
/// user interaction events globally.
UIApplicationMain(
    CommandLine.argc,
    CommandLine.unsafeArgv,
    NSStringFromClass(NCApplication.self),
    NSStringFromClass(AppDelegate.self)
)

/// Custom `UIApplication` subclass used to intercept all UIEvents
/// before they are dispatched to windows, scenes, and the view hierarchy.
///
/// This is the lowest and most reliable interception point in UIKit for
/// observing user interactions such as touches, presses, and motion events.
/// The implementation forwards events to `UserInteractionMonitor` while
/// preserving default UIKit behavior
final class NCApplication: UIApplication {
    /// Intercepts and forwards every UIEvent dispatched by the application.
    ///
    /// - Parameter event: The UIEvent generated by the system.
    ///
    /// This method must always call `super.sendEvent(_:)` to ensure
    /// normal event delivery. It is intentionally lightweight and delegates
    /// all processing to `UserInteractionMonitor`
    override func sendEvent(_ event: UIEvent) {
        super.sendEvent(event)
        UserInteractionMonitor.shared.handle(event: event)
    }
}

/// Centralized monitor for observing user interaction activity.
///
/// This class listens for low-level UIEvents and emits a notification
/// when a complete user interaction cycle has finished (i.e. all touches
/// have ended or been cancelled).
///
/// Typical use cases include:
/// - inactivity or idle detection
/// - global debouncing or refresh triggers
/// - analytics or telemetry
/// - security auto-lock timers
///
/// The monitor is intentionally decoupled from UI components and communicates
/// exclusively via NotificationCenter
final class UserInteractionMonitor {
    static let shared = UserInteractionMonitor()

    private init() {}

    /// Handles a UIEvent forwarded by the application.
    ///
    /// - Parameter event: The UIEvent received from `UIApplication.sendEvent(_:)`.
    ///
    /// Only touch events are considered. When all touches associated with the
    /// event are either `.ended` or `.cancelled`, a notification is posted
    /// indicating that a user interaction cycle has completed.
    ///
    /// The notification name is defined by `NCGlobal.shared.notificationCenterUserInteractionMonitor`
    func handle(event: UIEvent) {
        guard event.type == .touches else { return }
        guard let touches = event.allTouches, !touches.isEmpty else { return }

        let allEnded = touches.allSatisfy {
            $0.phase == .ended || $0.phase == .cancelled
        }

        if allEnded {
            NotificationCenter.default.post(name: Notification.Name(rawValue: NCGlobal.shared.notificationCenterUserInteractionMonitor), object: nil, userInfo: nil)
        }
    }
}
